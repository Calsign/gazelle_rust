load("@rules_rust//rust:defs.bzl", "rust_binary", "rust_library", "rust_proc_macro", "rust_test")
load("@bazel_gazelle//:def.bzl", "gazelle")

# Tell gazelle_rust where crate_universe dependencies come from:

# gazelle:rust_lockfile cargo.bazel.lock
# gazelle:rust_crates_prefix @crates//:

# Gazelle target using the gazelle_rust-provided gazelle binary. You can also create your own
# gazelle_binary target and add @gazelle_rust//rust_language to languages.
# Run with: bazel run //:gazelle
gazelle(
    name = "gazelle",
    gazelle = "@gazelle_rust//:gazelle_bin",
)

# Sample library. As new rust source files are added, rust_library targets will be created for them
# automatically. You can regroup source files into different targets, or change the rule to
# rust_binary or rust_test, and gazelle_rust will respect those changes.
rust_library(
    name = "lib",
    srcs = [
        "helper.rs",
        "lib.rs",
    ],
)

# Sample binary. gazelle_rust automatically adds the library dependency on lib and the
# crate_universe dependency on clap.
rust_binary(
    name = "main",
    srcs = ["main.rs"],
    proc_macro_deps = [":macro_lib"],
    deps = [
        ":lib",
        "@crates//:clap",
    ],
)

# Test targets are automatically created for targets that define inline tests. Test-only
# dependencies are correctly added to the test target.
rust_test(
    name = "lib_test",
    crate = ":lib",
    proc_macro_deps = [":macro_lib"],
)

# Standalone test targets work too.
rust_test(
    name = "standalone_test",
    srcs = ["standalone_test.rs"],
)

# proc_macro crates are handled correctly.
rust_proc_macro(
    name = "macro_lib",
    srcs = ["macro_lib.rs"],
    deps = [":lib"],
)
